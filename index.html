<!DOCTYPE html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultra-Smart Voter CSV Fixer</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#f6f8fb;padding:20px;color:#222}
  h1{font-size:20px;text-align:center;margin-bottom:6px}
  p.sub{ text-align:center;color:#555;margin-top:0;margin-bottom:18px}
  textarea{width:100%;min-height:240px;padding:12px;border:1px solid #d0d7e0;border-radius:6px;box-sizing:border-box;resize:vertical}
  .controls{display:flex;gap:10px;margin:12px 0}
  .controls button{flex:1;padding:12px;border:0;border-radius:6px;cursor:pointer;font-weight:600}
  #gen{background:#1366d6;color:#fff} #copy{background:#19a54b;color:#fff} #dl{background:#ff9800;color:#fff}
  #output{height:260px;font-family:Consolas,monospace}
  .note{color:#444;margin-top:8px;font-size:14px}
  @media (max-width:600px){.controls{flex-direction:column}}
</style>
</head>
<body>

<h1>Ultra-Smart Voter CSV Fixer üöÄ</h1>
<p class="sub">Raw voter text ‡§Ø‡§π‡§æ‡§Å paste ‡§ï‡§∞‡•á‡§Ç ‚Äî ‡§´‡§ø‡§∞ "Generate CSV" ‡§¶‡§¨‡§æ‡§è‡§Å‡•§</p>

<textarea id="inputText" placeholder="‡§Ø‡§π‡§æ‡§Å raw voter text ‡§™‡•á‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç..."></textarea>

<div class="controls">
  <button id="gen" onclick="generateCSV()">CSV Generate ‡§ï‡§∞‡•á‡§Ç</button>
  <button id="copy" onclick="copyCSV()" disabled>üìã Copy CSV</button>
  <button id="dl" onclick="downloadCSV()" disabled>‚¨áÔ∏è Download CSV</button>
</div>

<h3>Output CSV</h3>
<textarea id="output" readonly placeholder="Generated CSV will appear here..."></textarea>
<p class="note">Rules: EPIC (‡§ú‡•à‡§∏‡•á RBG... / MRL...) ‡§®‡§è voter entry ‡§ï‡•á ‡§∂‡•Å‡§∞‡•Å‡§Ü‡§§‡•Ä ‡§™‡•â‡§á‡§Ç‡§ü ‡§Æ‡§æ‡§®‡•á ‡§ú‡§æ‡§§‡•á ‡§π‡•à‡§Ç. Marathi digits (‡•¶-‡•Ø) auto-convert ‡§π‡•ã‡§Ç‡§ó‡•á.</p>

<script>
/* ===========================
   Utility helpers
   =========================== */
function devanagariToArabic(s){
  if(!s) return s;
  const map = {'‡•¶':'0','‡•ß':'1','‡•®':'2','‡•©':'3','‡•™':'4','‡•´':'5','‡•¨':'6','‡•≠':'7','‡•Æ':'8','‡•Ø':'9'};
  return s.replace(/[‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø]/g, d => map[d]);
}
function trimAndNorm(s){
  return (s||'').replace(/\s+/g,' ').replace(/^\s+|\s+$/g,'');
}
function escapeCSV(s){
  if(s==null) return 'NA';
  s = String(s);
  if(s.includes('"')) s = s.replace(/"/g,'""');
  if(s.includes(',') || s.includes('\n') || s.includes('"')) return `"${s}"`;
  if(s.trim()==='') return 'NA';
  return s;
}

/* ===========================
   Main parsing logic
   =========================== */

function generateCSV(){
  const raw = document.getElementById('inputText').value;
  const outEl = document.getElementById('output');
  const copyBtn = document.getElementById('copy');
  const dlBtn = document.getElementById('dl');

  if(!raw || !raw.trim()){
    alert('‡§ï‡•É‡§™‡§Ø‡§æ raw voter text ‡§™‡•á‡§∏‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç‡•§');
    return;
  }

  // Normalize common junk tokens and unify line breaks
  let norm = raw.replace(/\r/g,'\n');
  // Replace various 'Photo Available' variants and 'Available' and standalone '‡§®‡§æ‡§Ç‡§µ' tokens with a marker (we'll remove)
  norm = norm.replace(/\u00A0/g,' '); // non-break space
  norm = norm.replace(/Photo\s*Available/gi,' ');
  norm = norm.replace(/\bPhoto\b/gi,' ');
  norm = norm.replace(/\bAvailable\b/gi,' ');
  norm = norm.replace(/\b‡§®‡§æ‡§Ç‡§µ\s+‡§®‡§æ‡§Ç‡§µ\b/g,'‡§®‡§æ‡§Ç‡§µ');
  norm = norm.replace(/\|/g,' ');
  // Collapse multiple newlines to a single separator
  norm = norm.replace(/\n{2,}/g,'\n');

  // We will split the entire normalized text into tokens but primarily locate EPIC positions
  // EPIC pattern: three letters + digits/letters; allowing underscore; adjust to your dataset
  const epicRegex = /\b([A-Z]{2,3}[A-Z0-9_]{4,12})\s+(\d{1,3}\/\d{1,3}\/\d{1,3})\b/gi;

  const matches = [...norm.matchAll(epicRegex)];
  if(matches.length === 0){
    // try a slightly more permissive regex (some EPICs might be attached without space)
    const alt = [...norm.matchAll(/\b([A-Z]{2,3}[0-9_]{5,12})\b/gi)];
    if(alt.length === 0){
      outEl.value = 'SerialNo,EPIC_NO,PartNo,VoterName,RelationName,RelationType,HouseNo,Age,Gender\n‚ùå ‡§ï‡•ã‡§à EPIC ‡§™‡•à‡§ü‡§∞‡•ç‡§® ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ ‚Äî ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç ‡§ï‡§ø ‡§ü‡•á‡§ï‡•ç‡§∏‡•ç‡§ü ‡§Æ‡•á‡§Ç EPIC ‡§Æ‡•å‡§ú‡•Ç‡§¶ ‡§π‡•à‡•§';
      return;
    }
  }

  // Build blocks array: each block starts at an EPIC match and continues until next EPIC
  let blocks = [];
  for(let i=0;i<matches.length;i++){
    const startIdx = matches[i].index;
    const endIdx = (i+1 < matches.length) ? matches[i+1].index : norm.length;
    const chunk = norm.substring(startIdx, endIdx).trim();
    const epic = matches[i][1].trim();
    const part = matches[i][2] ? matches[i][2].trim() : 'NA';
    blocks.push({epic, part, chunk});
  }

  // If no matches (edge-case), fallback: treat entire text as one block
  if(blocks.length === 0){
    blocks = [{epic:'NA', part:'NA', chunk:norm}];
  }

  // Now parse each block
  const header = 'SerialNo,EPIC_NO,PartNo,VoterName,RelationName,RelationType,HouseNo,Age,Gender';
  let csv = header + '\n';
  let sn = 1;

  for(const b of blocks){
    let txt = b.chunk;

    // Replace newline inside chunk with space for easier regex matching
    txt = txt.replace(/\n/g,' ');
    txt = txt.replace(/\s+/g,' ').trim();

    // Remove repeated junk words left
    txt = txt.replace(/\b(‡§®‡§æ‡§Ç‡§µ|‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£:|‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£|‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£:)\b/gi,' ');
    txt = txt.replace(/\b(Photo|Available)\b/gi,' ');
    txt = txt.replace(/\s{2,}/g,' ').trim();

    // Extract VoterName
    let voterName = 'NA';
    // pattern 1: "‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£: <NAME> <maybe more> (‡§™‡§§‡•Ä‡§ö‡•á|‡§µ‡§°‡§ø‡§≤‡§æ‡§Ç‡§ö‡•á|‡§Ü‡§à‡§ö‡•á|‡§ò‡§∞ ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|RBG... )"
    let m = txt.match(/(?:‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£[:\s]*)?([^\:]*?)(?=\s+(?:‡§™‡§§‡•Ä‡§ö‡•á|‡§™‡§§‡•Ä|‡§µ‡§°‡§ø‡§≤‡§æ‡§Ç‡§ö‡•á|‡§Ü‡§à‡§ö‡•á|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|\b[A-Z]{2,3}[A-Z0-9_]{4,12}\b))/i);
    if(m && m[1] && m[1].trim()){
      voterName = trimAndNorm(m[1]);
    } else {
      // pattern 2: look for '‡§®‡§æ‡§Ç‡§µ' followed by some words
      m = txt.match(/‡§®‡§æ‡§Ç‡§µ[:\s]*([^\:|,]+?)(?=\s+(?:‡§™‡§§‡•Ä‡§ö‡•á|‡§µ‡§°‡§ø‡§≤‡§æ‡§Ç‡§ö‡•á|‡§Ü‡§à‡§ö‡•á|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|\b[A-Z]{2,3}[A-Z0-9_]{4,12}\b))/i);
      if(m && m[1] && m[1].trim()){
        voterName = trimAndNorm(m[1]);
      } else {
        // fallback: take initial sequence of Devanagari words up to first comma or relation keyword
        m = txt.match(/^([^\dA-Z:,]{2,120}?)(?=\s+(?:‡§™‡§§‡•Ä‡§ö‡•á|‡§µ‡§°‡§ø‡§≤‡§æ‡§Ç‡§ö‡•á|‡§Ü‡§à‡§ö‡•á|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|\b[A-Z]{2,3}[A-Z0-9_]{4,12}\b|$))/i);
        if(m && m[1] && m[1].trim()){
          voterName = trimAndNorm(m[1]);
        }
      }
    }

    // If voterName still NA, try taking text before EPIC in chunk
    if(voterName === 'NA'){
      // remove epic and part if present
      const removeEP = txt.replace(b.epic,'').replace(b.part,'').trim();
      if(removeEP.length>0 && removeEP.length < 120) voterName = trimAndNorm(removeEP.split(/‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§°‡§ø‡§≤|‡§™‡§§‡•Ä|‡§Ü‡§à|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó/i)[0] || removeEP);
    }

    // Extract relation name & type
    let relationName = 'NA', relationType = 'NA';
    // p: ‡§™‡§§‡•Ä‡§ö‡•á ‡§®‡§æ‡§µ
    let p = txt.match(/‡§™‡§§‡•Ä‡§ö‡•á\s*‡§®‡§æ‡§µ\s*[:\s]*([^\:|,]+?)(?=\s+(?:‡§µ‡§°‡§ø‡§≤|‡§Ü‡§à|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i)
      || txt.match(/‡§™‡§§‡•Ä\s*[:\s]*([^\:|,]+?)(?=\s+(?:‡§µ‡§°‡§ø‡§≤|‡§Ü‡§à|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i);
    if(p && p[1]){ relationName = trimAndNorm(p[1]); relationType = 'Husband'; }

    // father
    let f = txt.match(/‡§µ‡§°‡§ø‡§≤(?:‡§æ‡§Ç‡§ö‡•á)?\s*‡§®‡§æ‡§µ\s*[:\s]*([^\:|,]+?)(?=\s+(?:‡§™‡§§‡•Ä|‡§Ü‡§à|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i)
      || txt.match(/‡§µ‡§°‡§ø‡§≤(?:‡§æ‡§Ç‡§ö‡•á)?\s*[:\s]*([^\:|,]+?)(?=\s+(?:‡§™‡§§‡•Ä|‡§Ü‡§à|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i)
      || txt.match(/\bFather[:\s]*([^\:|,]+?)(?=\s+(?:‡§™‡§§‡•Ä|‡§Ü‡§à|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i);
    if(f && f[1]){ relationName = trimAndNorm(f[1]); relationType = 'Father'; }

    // mother
    let fm = txt.match(/‡§Ü‡§à(?:‡§ö‡•á)?\s*‡§®‡§æ‡§µ\s*[:\s]*([^\:|,]+?)(?=\s+(?:‡§™‡§§‡•Ä|‡§µ‡§°‡§ø‡§≤|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i)
      || txt.match(/‡§Ü‡§à(?:‡§ö‡•á)?\s*[:\s]*([^\:|,]+?)(?=\s+(?:‡§™‡§§‡•Ä|‡§µ‡§°‡§ø‡§≤|‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï|‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i);
    if(fm && fm[1]){ relationName = trimAndNorm(fm[1]); relationType = 'Mother'; }

    // Extract House No
    let house = 'NA';
    let hs = txt.match(/‡§ò‡§∞\s*‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï\s*[:\s]*([^,|:]+?)(?=\s+(?:‡§µ‡§Ø|‡§≤‡§ø‡§Ç‡§ó|$))/i);
    if(hs && hs[1]) house = trimAndNorm(hs[1]);
    else {
      // sometimes house appears as "M. S chawl" or "MS CHAWL" etc without '‡§ò‡§∞ ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï'
      let altHouse = txt.match(/\b([A-Za-z0-9\.\- ]+(?:CHAWL|chawl|Chawl|Compound|COMPOUND|GALA|GALA NO|BUNGALOW|niwas|Niwas|NAGAR|NAGAR,?))\b/);
      if(altHouse && altHouse[1]) house = trimAndNorm(altHouse[1]);
    }

    // Extract Age (Devanagari or Arabic)
    let age = 'NA';
    let ageMatch = txt.match(/‡§µ‡§Ø\s*[:\s]*([‡•¶-‡•Ø0-9]{1,3})/i);
    if(ageMatch && ageMatch[1]) age = devanagariToArabic(ageMatch[1]);
    else {
      // fallback numeric
      let num = txt.match(/\b([0-9]{1,3})\b/);
      if(num && num[1]) age = num[1];
    }

    // Extract Gender
    let gender = 'NA';
    let g = txt.match(/‡§≤‡§ø‡§Ç‡§ó\s*[:\s]*(‡§™‡•Å|‡§™‡•Å‡§∞‡•Å‡§∑|‡§∏‡•ç‡§§‡•ç‡§∞‡•Ä|‡§Æ‡§π‡§ø‡§≤‡§æ|male|female)/i);
    if(g && g[1]){
      let gg = g[1].toString().toLowerCase();
      if(/‡§∏‡•ç‡§§‡•ç‡§∞‡•Ä|‡§Æ‡§π‡§ø‡§≤‡§æ|female/i.test(gg)) gender = 'Female';
      else if(/‡§™‡•Å|‡§™‡•Å‡§∞‡•Å‡§∑|male/i.test(gg)) gender = 'Male';
    } else {
      // look for explicit '‡§≤‡§ø‡§Ç‡§ó : ‡§™‡•Å' elsewhere in the block
      if(/\b‡§≤‡§ø‡§Ç‡§ó\s*:\s*‡§∏‡•ç‡§§‡•ç‡§∞‡•Ä\b/i.test(txt)) gender='Female';
      if(/\b‡§≤‡§ø‡§Ç‡§ó\s*:\s*‡§™‡•Å\b|\b‡§≤‡§ø‡§Ç‡§ó\s*:\s*‡§™‡•Å‡§∞‡•Å‡§∑\b/i.test(txt)) gender='Male';
    }

    // Final cleanup: remove stray tokens left in names
    const junkWords = /\b(Photo|Available|‡§®‡§æ‡§Ç‡§µ|‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á|‡§Æ‡§§‡§¶‡§æ‡§∞‡§æ‡§ö‡•á ‡§™‡•Ç‡§∞‡•ç‡§£|Photo Available)\b/gi;
    if(voterName && voterName!=='NA') voterName = voterName.replace(junkWords,'').trim();
    if(relationName && relationName!=='NA') relationName = relationName.replace(junkWords,'').trim();
    if(house && house!=='NA') house = house.replace(junkWords,'').trim();

    if(!voterName || voterName.length===0) voterName='NA';
    if(!relationName || relationName.length===0) relationName='NA';
    if(!house || house.length===0) house='NA';
    if(!age || age.length===0) age='NA';
    if(!gender || gender.length===0) gender='NA';

    // Ensure EPIC and Part default
    let epicOut = b.epic || 'NA';
    let partOut = b.part || 'NA';

    // Escape for CSV where necessary
    const row = [
      sn,
      escapeCSV(epicOut),
      escapeCSV(partOut),
      escapeCSV(voterName),
      escapeCSV(relationName),
      escapeCSV(relationType),
      escapeCSV(house),
      escapeCSV(age),
      escapeCSV(gender)
    ].join(',');

    csv += row + '\n';
    sn++;
  }

  outEl.value = csv;
  copyBtn.disabled = false;
  dlBtn.disabled = false;
}

/* Copy and Download helpers */
function copyCSV(){
  const out = document.getElementById('output');
  if(!out.value){ alert('‡§™‡§π‡§≤‡•á CSV ‡§ú‡§®‡§∞‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç'); return; }
  navigator.clipboard.writeText(out.value).then(()=>{
    alert('CSV copied to clipboard ‚úÖ');
  }).catch(()=>alert('Copy failed ‚Äî please select and copy manually.'));
}

function downloadCSV(){
  const out = document.getElementById('output');
  if(!out.value){ alert('‡§™‡§π‡§≤‡•á CSV ‡§ú‡§®‡§∞‡•á‡§ü ‡§ï‡§∞‡•á‡§Ç'); return; }
  const blob = new Blob([out.value], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'voter_cleaned.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* ===========================
   End
   =========================== */
</script>

</body>
</html>
